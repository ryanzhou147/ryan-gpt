<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>RyanGPT Chat</title>
    <link rel="stylesheet" href="/static/style.css">
  </head>
  <body>
    <div id="app"></div>

    <script src="https://unpkg.com/vue@3/dist/vue.global.prod.js"></script>
    <script>
    const { createApp, ref, reactive, onMounted } = Vue;

    const App = {
      template: `
      <div class="app">
        <header class="topbar">
          <h1>RyanGPT</h1>
            <div class="controls">
              <label class="switch-label">Model
                <select v-model="selected_model">
                  <option v-for="m in models" :key="m.id" :value="m.checkpoint">{{ m.label }}</option>
                </select>
              </label>
              <label class="switch-label">Temp
                <input v-model.number="temperature" @blur="onTempBlur" type="number" min="0.01" max="0.99" style="width:50px" />
              </label>
              <label class="switch-label">Min Tokens
                <input v-model.number="min_tokens" @blur="onMinTokensBlur" type="number" min="10" max="140" style="width:50px" />
              </label>
            </div>
        </header>

        <main class="chat-container">
          <div class="messages">
            <div v-for="(m, idx) in messages" :key="idx" :class="['msg', m.role==='user' ? 'user' : 'bot']">
              <div v-if="m.role === 'bot'" class="meta">Assistant</div>
              <div class="body">{{ m.text }}</div>
            </div>
          </div>
        </main>

        <footer class="composer">
            <textarea id="prompt" v-model="prompt" placeholder="Send a message..." rows="2" style="width:800px"></textarea>
          <div class="composer-controls">
            <button @click="send" id="send" aria-label="Send">
              <!-- up arrow icon -->
              <svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
                <path d="M12 19V5" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                <path d="M5 12l7-7 7 7" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
              </svg>
            </button>
          </div>
        </footer>
      </div>
      `,
      setup(){
        const models = ref([]);
        const selected_model = ref('');
        const prompt = ref('');
        const messages = reactive([]);
        const temperature = ref(0.5);
        const min_tokens = ref(5);

        // clamp on blur handlers (only enforce when user leaves the input)
        function onTempBlur(){
          let val = parseFloat(temperature.value);
          if (!isFinite(val)) val = 0.5;
          if (val <= 0.0) val = 0.01;
          if (val >= 1.0) val = 0.99;
          if (val < 0.01) val = 0.01;
          const rounded = Math.round(val * 100) / 100;
          temperature.value = rounded;
        }

        function onMinTokensBlur(){
          let val = parseInt(min_tokens.value) || 5;
          if (val < 5) val = 5;
          else if (val > 140) val = 140;
          min_tokens.value = val;
        }

        function append(role, text){
          messages.push({role, text});
          // scroll
          setTimeout(()=>{
            const el = document.querySelector('.chat-container');
            if(el) el.scrollTop = el.scrollHeight;
          }, 50);
        }

        async function send(){
          const text = prompt.value.trim();
          if(!text) return;
          append('user', text);
          prompt.value = '';
          append('bot', '...');

          try{
            // clamp/validate before sending
            let tempVal = parseFloat(temperature.value);
            if (!isFinite(tempVal)) tempVal = 0.5;
            if (tempVal <= 0.0) tempVal = 0.01;
            if (tempVal >= 1.0) tempVal = 0.99;

            let minT = parseInt(min_tokens.value) || 5;
            if (minT < 5) minT = 5;
            if (minT > 140) minT = 140;

            const res = await fetch('/api/chat', {
              method: 'POST',
              headers: {'Content-Type':'application/json'},
              body: JSON.stringify({
                model: selected_model.value,
                prompt: text,
                min_tokens: minT,
                temperature: tempVal,
              })
            });
            const data = await res.json();
            if(data.error){
              messages[messages.length-1].text = 'Error: ' + data.error;
            } else {
              messages[messages.length-1].text = data.reply;
            }
          } catch(err){
            messages[messages.length-1].text = 'Error: ' + err.message;
          }
        }

        // fetch available models and handle enter-to-send
        onMounted(async ()=>{
          try{
            const r = await fetch('/api/models');
            const j = await r.json();
            if(j.models && j.models.length){
              // prefer specific run folders; fall back to presets
              const findById = (id) => j.models.find(m => m.id === id);

              const finetuneRun = findById('finetune_chinchilla_style_deep');
              const pretrainRun = findById('pretrain_chinchilla_style_deep');

              const chatPreset = findById('chat');
              const wikiPreset = findById('wikipedia');

              const finetuneOption = finetuneRun ?
                { id: 'finetune', label: 'finetune (chat)', checkpoint: finetuneRun.checkpoint } :
                { id: 'finetune', label: 'finetune (chat)', checkpoint: (chatPreset && chatPreset.checkpoint) || '' };

              const pretrainOption = pretrainRun ?
                { id: 'pretrain', label: 'pretrain (wikipedia)', checkpoint: pretrainRun.checkpoint } :
                { id: 'pretrain', label: 'pretrain (wikipedia)', checkpoint: (wikiPreset && wikiPreset.checkpoint) || '' };

              models.value = [finetuneOption, pretrainOption];
              selected_model.value = models.value[0].checkpoint || '';
            }
          }catch(e){
            console.warn('Could not fetch models', e);
          }

          document.addEventListener('keydown', (e)=>{
            if(e.key === 'Enter' && !e.shiftKey){
              const active = document.activeElement;
              if(active && active.tagName === 'TEXTAREA'){
                e.preventDefault();
                send();
              }
            }
          });
        });

        return { models, selected_model, prompt, messages, min_tokens, temperature, send, onTempBlur, onMinTokensBlur };      }
    };

    createApp(App).mount('#app');
    </script>
  </body>
</html>
